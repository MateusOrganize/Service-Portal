<?xml version="1.0" encoding="UTF-8"?>
<unload unload_date="2020-11-13 19:33:43">
<sys_script_include action="INSERT_OR_UPDATE">
<access>public</access>
<active>true</active>
<api_name>global.chartData</api_name>
<caller_access/>
<client_callable>false</client_callable>
<description/>
<name>chartData</name>
<script><![CDATA[var chartData = Class.create();
chartData.prototype = {
	/*
	If you want to order the chart in the same way as the report. Use the following code or something similar
	
	series.sort(function (a, b) {
		if (a.data.length > b.data.length)
			return 1;
		if (a.data.length < b.data.length)
			return -1;
		// 'a' must be equal to 'b'
		return 0;
	});
	
	*/
	
	
	/**SNDOC
	@name initialize
    @description Constructor method of chartData
    @param {object} [options] -  Object containing the report configuration values
	*/
	initialize: function(options) {
		this.options = options;
	},

	/**SNDOC
	@name getQuery
    @description Make a Glide Aggragate Query
    @returns {Glide Aggragate} The Glide Aggragate
    @example

    var chart = new chartData(options);
	var agg = chartData.getQuery();
	
	while(agg.next()){
		...
	}
	*/
	getQuery: function(){		
		var agg = new GlideAggregate(this.options.table);
		agg.addAggregate(this.options.agg,this.options.sum_field);
		agg.groupBy(this.options.field);
		if(this.options.trend_field)
			agg.groupBy(this.options.trend_field);
		agg.addEncodedQuery(this.options.filter);
		agg.orderBy(this.options.field);
		if(this.options.trend_field)
			agg.orderBy(this.options.trend_field);
		agg.query();

		return agg;
	},

	/**SNDOC
	@name getRectangles
    @description Get the chart data, only just for Bars and Columns graphs
    @returns {object} Object containing the series and categories 
    @example

    var chart = new chartData(options);
	var chartData = chart.getRectangles();

	//Output:
	 {
		categories:["", "2016", "2018", "2020"],
		series:[
			{data: [1,2,3,4], name: ""},
		]
	 }
	*/
	getRectangles: function(){
		var data = [], categories = [];
		var agg = this.getQuery();

		while (agg.next()) {
			data.push(parseInt(agg.getAggregate(this.options.agg,this.options.sum_field)));
			categories.push(agg.getDisplayValue(this.options.field));
		}
		//Edite aqui o series
		var series = [{
			data: data,
			name: '',
			color: this.getColor()
		}];
		return {series: series, categories: categories};
	},

	/**SNDOC
	@name getStackRectangles
    @description Get the chart data, only just for Bars and Columns graphs that are STACKED
    @returns {object} Object containing the series and categories 
    @example

    var chart = new chartData(options);
	var chartData = chart.getStackRectangles();

	//Output:
	 {
		categories:["", "2016", "2018", "2020"],
		series:[
			{data: [1,2], name: "New"},
			{data: [3,2,4], name: "In Progress"},
			{data: [3,2,4], name: "On Hold"},
			{data: [1,2], name: "Closed"}
		]
	 }
	*/
	getStackRectangles: function(){
		var series = [], names = [], categories = [];
		var cat, n, value, isFirst = true;
		var tam = 1;

		var agg = this.getQuery();

		while (agg.next()) {
			cat = agg.getDisplayValue(this.options.field);
			n = agg.getDisplayValue(this.options.trend_field);
			value = parseFloat(agg.getAggregate(this.options.agg,this.options.sum_field));

			if(names.indexOf(n) == -1){
				names.push(n);
				//Edite aqui o series
				series.push({
					//color: #e35f75,
					name: n,
					data: [value]
				});
				if(categories.indexOf(cat) == -1)
					categories.push(cat);
				if(categories.length > tam)
					this.fixArray(series, categories.length);
				continue;
			}

			if(categories.indexOf(cat) == -1){
				categories.push(cat);
				this.fixArray(series, tam);
			}

			series[names.indexOf(n)].data.push(value);
			if(series[names.indexOf(n)].data.length > tam)
				tam = series[names.indexOf(n)].data.length;
		}

		if(series.length > 0)
			this.fixArray(series, tam);
		return {series: series, categories: categories};
	},

	/**SNDOC
	@name getCircles
    @description Get the chart data, only just for Pie and Donuts graphs
    @returns {object} Object containing the series and categories 
    @example

    var chart = new chartData(options);
	var chartData = chart.getCircles();

	//Output:
	 {
		categories: "",
		series:[
			colorByPoint: true,
			data: [
				{name: "New", y: 0},
				{name: "Assess", y: 1500},
				{name: "Root Cause Analysis", y: 16801}
			]
			innerSize: "0%",
			name: "",
			type: "pie"
		]
	 }
	*/
	getCircles: function(){
		var data = [];
		var agg = this.getQuery();

		while (agg.next()) {
			data.push({
				y: parseFloat(agg.getAggregate(this.options.agg,this.options.sum_field)),
				name: agg.getDisplayValue(this.options.field)
			});
		}

		var innerSize = '0%';
		if(this.options.type == 'donut' || this.options.type == 'semi_donut')
			innerSize = '40%';
		//Edite aqui o series
		var series = [{
			data: data,
			type: 'pie',
			name: '',
			innerSize: innerSize,
			colorByPoint: true
		}];
		return {series: series, categories: ''};
	},

	/**SNDOC
	@name getLines
    @description Get the chart data, only just for Line and Area graphs
    @returns {object} Object containing the series and categories 
    @example

    var chart = new chartData(options);
	var chartData = chart.getLines();

	//Output:
	 {
		categories:["", "2016", "2018", "2020"],
		series:[
			{data: [1,2], name: "New"},
			{data: [3,2,4], name: "In Progress"},
			{data: [3,2,4], name: "On Hold"},
			{data: [1,2], name: "Closed"}
		]
	 }
	*/
	getLines: function(){
		var names = [], categories = [], series = [];
		var index, n, value, tam = 1;
		var newCategorie = false;

		var ga = new GlideAggregate('incident');
		ga.orderBy('state');
		ga.addAggregate("COUNT");
		ga.addTrend("resolved_at", 'year');
		ga.query();

		var count = 0;
		while(ga.next()) {
			n = ga.getDisplayValue('state');
			value = parseFloat(ga.getAggregate('COUNT'));
			index = names.indexOf(n);

			if(categories.length == 0)
				categories.push('');

			if(ga.getValue('timeref') != null){
				categories.push(ga.getValue('timeref'));
				newCategorie = true;
			}

			if(index == -1){
				names.push(n);
				index = names.indexOf(n);
				series.push({
					name: names[index],
					data: [value]
				});

				if(newCategorie && series[index].data.length == 1){
					this.fixLineArray(series[index].data, categories.length);
					newCategorie = false;
				}
			}else 
				series[index].data.push(value);
			
			if(series[index].data.length > tam)
				tam = series[index].data.length;
		}
		this.addZero(series);
		return {series: series, categories: categories};
	},

	/**SNDOC
	@name fixArray
    @description This function complements the gaps in objects "data" within the "series", it is to keep all arrays aligned.
	@param {array} [series] - The chart series
    @param {integer} [tam] - The length of the bigger 'data'
    @example
	
	var chart = new chartData(options);
	var series = [
			{name: 'A', data: [1,2,3]},
			{name: 'B',data: [3]}
		]
		
	chart.fixArray(series);
		
	//Output:
	[
		{name: "A", data: [1,2,3]},
		{name: "B", data: [0,0,3]}
	]
	*/
	fixArray: function(series, tam){
		for (var j=0; j < series.length; j++){
			if(series[j].data.length == 1 && tam > 1){
				var aux = series[j].data.pop();
				while(series[j].data.length < tam - 1)
					series[j].data.push(0);
				series[j].data.push(aux);
			}else
				while(series[j].data.length < tam)
					series[j].data.push(0);
		}
	},
	
	/**SNDOC
	@name fixLineArray
    @description This function complements the gaps in the "data" array when a new category is found it is to keep aligned the "data" array.
	@param {array} [data] - The value of "series.data"
    @param {integer} [tam] - The length of the bigger 'data' 
    @example
	
	var chart = new chartData();
	var series = [
			{name: 'A', data: [1,2,3]},
			{name: 'B',data: [4]}
		]
	chart.fixLineArray(series[1].data, 3);
		
	//Output:
		data: [0,0,4]
	*/
	fixLineArray: function(data, tam){
		var aux = data.pop();
		while((tam - 1) > data.length)
			data.push(0);
		data.push(aux);
	},

	/**SNDOC
	@name addZero
    @description Add a zero to the arrays with a length like 1. This function exists because a Line/Area chart needs at least two points.
	@param {array} [series] - The chart series
    @example
	
	var chart = new chartData();
	var series = [
			{name: 'A', data: [1,2,3]},
			{name: 'B',data: [4]}
		]
	chart.addZero(series[1].data, 3);
		
	//Output:
		series = [
			{name: 'A', data: [1,2,3]},
			{name: 'B',data: [4,0]}
		]
	*/
	addZero: function(series){
		for (var j=0; j < series.length; j++){
			if(series[j].data.length == 1){
				series[j].data.push(0);
			}
		}
	},

	type: 'chartData'
};]]></script>
<sys_class_name>sys_script_include</sys_class_name>
<sys_created_by>admin</sys_created_by>
<sys_created_on>2020-11-06 19:07:09</sys_created_on>
<sys_id>3b15480a2f54a010c5d33f96f699b6f9</sys_id>
<sys_mod_count>58</sys_mod_count>
<sys_name>chartData</sys_name>
<sys_package display_value="Global" source="global">global</sys_package>
<sys_policy/>
<sys_scope display_value="Global">global</sys_scope>
<sys_update_name>sys_script_include_3b15480a2f54a010c5d33f96f699b6f9</sys_update_name>
<sys_updated_by>admin</sys_updated_by>
<sys_updated_on>2020-11-11 18:41:29</sys_updated_on>
</sys_script_include>
</unload>
